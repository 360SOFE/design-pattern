# 前言

## 面向对象六+一大设计原则

### 一、单一职责原则 S 

> - 单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分

> - 单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性

> - 针对：类 方法

### 二、开闭原则 O 

> - 对扩展开放、对修改关闭

> - 针对：模块 方法 类 接口

> - 实现方法：利用接口或抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

### 三、里氏替换原则 L 

> - 只要父类能出现的地方子类都可以出现，而且替换为子类也不会产生任何错误和异常 => 子类可以扩展父类的功能，但不能改变父类原有的功能

> - 抽象化的具体规范

> - 主要针对：类

抽象原则
- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
- 子类中可以增加自己特有的方法
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
- 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等

### 四、依赖倒置原则 D 

> - 面向接口编程，不要面向实现编程。

> - 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

> - 针对：模块 类

原则

- 每个类尽量提供接口或抽象类，或者两者都具备。
- 变量的声明类型尽量是接口或者是抽象类。
- 任何类都不应该从具体类派生。
- 使用继承时尽量遵循里氏替换原则。

### 五、接口隔离原则  I

> - 要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

> - 针对：接口

### 六、迪米特法则  Law

> - 迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话

> - 其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。

> - 目的是降低类之间的耦合度，提高模块的相对独立性。

> - 针对：类 模块 软件（通讯）

### + 1 合成复用原则

### 继承的局限

- 继承复用破坏了类的封装性。
- 子类与父类的耦合度高。
- 它限制了复用的灵活性
- 优先使用组合或聚合，继承次之

> - 优先使用组合或聚合，继承次之

> - 类 方法

### 统揽图

![设计模式](../.gitbook/assets/mzm/design.png)

## 23种设计模式

### 概览

![23种设计模式](../.gitbook/assets/mzm/23design.png)
![23种设计模式表格](../.gitbook/assets/mzm/designform.png)

### 创建型模式----将对象的创建与使用分离

> - 单例（Singleton）模式：          某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例。

> - 原型（Prototype）模式：          将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。

> - 工厂方法（FactoryMethod）模式：  定义一个用于创建产品的接口，由子类决定生产什么产品。

> - 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。

> - 建造者（Builder）模式：          将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

### 结构型

![23种设计模式](../.gitbook/assets/mzm/design_struct.png)

### 行为型设计模式--算法和对象间的职责分配

>- 职责链	 将对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。
>- 命令模式	 在你的请求和处理之间加上了一个中间人的角色，来达到分离耦合的目的。
>- 解释器	 定义语言（使用规定格式和语法的代码）的文法，并且建立一个解释器来解释该语言中的句子。
>- 迭代器	 提供一种方法顺序访问一个集合中各个元素，而又不暴露该对象的内部表示。
>- 中介者	 用一个中介对象封装一系列的对象交互。中介者使各对象间不需要显式的相互引用，从而使其松散耦合，而起可以独立的改变它们之间的交互。
>- 备忘录	 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以后可将该对象恢复到原先保存的状态。
>- 观察者	 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并自动更新。
>- 状态	     允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
>- 策略	     定义一系列算法，把它们一个个封装起来，并且使它们可相互替换，本模式使得算法可独立于使用它的客户而变化。
>- 模版方法	 定义一个操作中算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法的某些特定的步骤。
>- 访问者    表示以作用于对象结构中各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
